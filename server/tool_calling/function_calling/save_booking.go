package function_calling

import (
	"encoding/json"
	"fmt"
	"time"

	"resort-app-server/models"
	"resort-app-server/repository"
)

// BookingData represents the data structure for booking function calling
type BookingData struct {
	ResortName   string  `json:"resort_name"`
	CheckIn      string  `json:"check_in"`
	CheckOut     string  `json:"check_out"`
	Guests       int     `json:"guests"`
	TotalPrice   float64 `json:"total_price"`
	CustomerName string  `json:"customer_name"`
	PhoneNumber  string  `json:"phone_number"`
}

// ExtractBookingData extracts booking data from AI response when function calling is executed
func ExtractBookingData(messageContent string) (*BookingData, bool) {
	// Look for booking data in the format specified in the system prompt
	startTag := "<BOOKING_DATA>"
	endTag := "</BOOKING_DATA>"

	startIdx := FindStringIndex(messageContent, startTag)
	if startIdx == -1 {
		return nil, false
	}

	endIdx := FindStringIndex(messageContent, endTag)
	if endIdx == -1 {
		return nil, false
	}

	// Extract the JSON data between the tags
	bookingDataJSON := messageContent[startIdx+len(startTag) : endIdx]
	// Clean up whitespace
	bookingDataJSON = TrimString(bookingDataJSON)

	// Parse the JSON into a BookingData struct
	var bookingData BookingData
	if err := json.Unmarshal([]byte(bookingDataJSON), &bookingData); err != nil {
		fmt.Printf("Error parsing booking data: %v\n", err)
		return nil, false
	}

	return &bookingData, true
}

// ValidateBookingData ensures booking data is valid before saving
func ValidateBookingData(booking *BookingData) error {
	validResorts := map[string]bool{
		"Garden Cottage":  true,
		"Pool Villa":      true,
		"Beach House":     true,
		"Mountain Cabin":  true,
		"Log Cabin":       true,
		"Luxury Lodge":    true,
		"City Apartment":  true,
		"Penthouse Suite": true,
		"Executive Loft":  true,
	}

	// Validasi resort name
	if !validResorts[booking.ResortName] {
		return fmt.Errorf("invalid resort name: %s", booking.ResortName)
	}

	// Validasi required fields
	if booking.CustomerName == "" {
		return fmt.Errorf("customer name is required")
	}

	if booking.PhoneNumber == "" {
		return fmt.Errorf("phone number is required")
	}

	if booking.CheckIn == "" {
		return fmt.Errorf("check-in date is required")
	}

	if booking.Guests <= 0 {
		return fmt.Errorf("number of guests must be greater than 0")
	}

	// Validasi format tanggal
	_, err := time.Parse("2006-01-02", booking.CheckIn)
	if err != nil {
		return fmt.Errorf("invalid check-in date format: %s", booking.CheckIn)
	}

	return nil
}

// SaveBookingToDatabase saves the booking data to the database
func SaveBookingToDatabase(bookingData *BookingData) error {
	// Convert BookingData to models.Booking
	booking := &models.Booking{
		// ID (booking ID) is auto-generated by the database
		UserID:       0, // Anonymous user ID for public bookings
		ResortName:   bookingData.ResortName,
		CheckIn:      bookingData.CheckIn,
		CheckOut:     bookingData.CheckOut,
		Guests:       bookingData.Guests,
		TotalPrice:   bookingData.TotalPrice,
		Status:       "pending", // Default status
		PaymentDate:  "",        // Will be set when payment is processed
		CustomerName: bookingData.CustomerName,
		PhoneNumber:  bookingData.PhoneNumber,
		// CreatedAt is set automatically by the database
	}

	// Save to database
	return repository.CreateBooking(booking)
}